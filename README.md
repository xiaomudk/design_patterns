# 设计模式 python实现

### 参考

- [图解设计模式](https://book.douban.com/subject/26933281/)
- [设计模式 可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)


### 什么设计模式

1. 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

2. 设计模式的四个基本要素:
   - 模式名称: 一个助记名。
   - 问题: 描述了应该在何时使用模式。
   - 解决方案: 描述了设计的组成成分,他们之间的相互关系及各自的职责和协作方式。
   - 效果: 描述了模式应用的效果及使用模式应权衡的问题。 

### 描述设计模式

- 模式名和分类
- 意图
- 别名
- 动机
- 适用性
- 结构
- 参与者
- 协作
- 效果
- 实现
- 代码示例
- 已知应用
- 相关模式

### 设计模式分类

 1. 按目的(用来完成什么工作)分类

 - 创建型
 - 结构型
 - 行为型

 > 创建型模式与对象的创建有关；
 > 结构型模式处理类或对象的组合；
 > 行为型模式对类或对象怎样交互和怎样分配职责进行描述。

 > 创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。
 > 结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。
 > 行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。

 2. 按范围(用于类或对象)分类

 

 > 类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。
 > 对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。


### 设计模式怎样解决设计问题

*1.寻找合适的对象*
  对象包括数据和对数据进行操作的过程，过程通常称为方法
或操作

*2.决定对象的粒度*

*3.指定对象接口*
对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构(signature)。对象操作所定义的所有操作型构的集合被称为该对象的接口(interface)。

*4.描述对象的实现*

设计原则: 针对接口编程，而不是针对实现编程。 (其实就是多使用多态)

*5.运用复用机制*

- 1. 继承和组合

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

设计原则: 优先使用对象组合，而不是类继承

- 2. 妥托

  接受请求的对象将自己传给被委托者（代理人），使被委托的操作可以引用接受请求的对象。
  委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承。

- 3. 参数化类型(泛型)

  参数化类型给我们提供除了类继承和对象组合外的第三种方法来组合面向对象系统中的行为。

对象组合技术允许你在运行时刻改变被组合的行为，
但是它存在间接性，比较低效。
继承允许你提供操作的缺省实现，并通过子类重定义这些操
作。参数化类型允许你改变类所用到的类型。但是继承和参数化类型都不能在运行时刻改变。哪一种方法最佳，取决于你设计和实现的约束条件。

*6.关联运行时刻和编译时刻的结构*

  聚合意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象包含另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期。
  相识意味着一个对象仅仅知道另一个对象。有时相识也被称为“关联”或“引用”关系。相识的对象可能请求彼此的操作，但是它们不为对方负责。相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系。

*7.设计应该支持变化*
  
  获得最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计要能够相应地改进。

### 怎么选择设计模式

-  考虑设计模式是怎样解决设计问题的
-  浏览模式的意图部分
-  研究模式怎样互相关联
-  研究目的相似的模式
-  检查重新设计的原因
-  考虑你的设计中哪些是可变的

*8.怎么使用设计模式*

- 大致浏览一遍模式
- 回头研究结构部分、参与者部分和协作部分
- 看代码示例部分，看看这个模式代码形式的具体例子
- 选择模式参与者的名字，使它们在应用上下文中有意义
- 定义类
- 定义模式中专用于应用的操作名称
- 实现执行模式中责任和协作的操作


设计模式不能够随意使用。通常你通过引入额外的间接层次获得灵活性和可变性的同时，你也使设计变得更复杂并 /或牺牲了一定的性能。一个设计模式只有当它提供的灵活性是真正需要的时候，才有必要使用。

### 创建型模式